# -*- coding: utf-8 -*-
"""fuzzyOOP.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/17FgiL38x9f6R9xRPDKTLJ6IG_EoHSJyw
"""

import os

import numpy as np
import skfuzzy as fuzz
from skfuzzy import control as ctrl
from pymongo import MongoClient


class FuzzyKernel():
    def __init__(self):
        self.ages = ['baby', 'child', 'preteen', 'adult1', 'adult2', 'old']
        self.lengths = ['short', 'medium', 'long', 'multylong']
        self.rates = ['anything', 'belowaverage', 'medium', 'good', 'amazing']
        # Antecedents
        self.length = ctrl.Antecedent(np.arange(0, 101, 1), 'length')
        self.age = ctrl.Antecedent(np.arange(0, 101, 1), 'age')

        self.length['short'] = fuzz.trapmf(self.length.universe, [0, 5, 15, 25])
        self.length['medium'] = fuzz.trapmf(self.length.universe, [20, 30, 35, 45])
        self.length['long'] = fuzz.trapmf(self.length.universe, [35, 45, 55, 60])
        self.length['multylong'] = fuzz.trapmf(self.length.universe, [55, 60, 100, 100])

        self.age['baby'] = fuzz.trapmf(self.age.universe, [0, 3, 6, 9])
        self.age['child'] = fuzz.trapmf(self.age.universe, [6, 8, 11, 13])
        self.age['preteen'] = fuzz.trapmf(self.age.universe, [12, 13, 14, 15])
        self.age['teen'] = fuzz.trapmf(self.age.universe, [14, 15, 19, 21])
        self.age['adult1'] = fuzz.trapmf(self.age.universe, [19, 21, 38, 42])
        self.age['adult2'] = fuzz.trapmf(self.age.universe, [38, 42, 58, 62])
        self.age['old'] = fuzz.trapmf(self.age.universe, [58, 62, 100, 100])

        # Consequents
        self.consequents = {}

        # Rules
        self.rules = []

        # Controls
        self.rules_ctrl = ctrl.ControlSystem(self.rules)
        self.rules_ = ctrl.ControlSystemSimulation(self.rules_ctrl)

    def get_path(self, filename):
        file_path = os.path.abspath(__file__)
        edited_path = file_path[:-11].replace("\\", "/")
        res_path = edited_path + filename
        return res_path

    def addConsequent(self, id):
        self.consequents.update({id: ctrl.Consequent(np.arange(0, 101, 1), id)})
        self.consequents[id]['anything'] = fuzz.trapmf(self.consequents[id].universe, [0, 5, 5, 10])
        self.consequents[id]['belowaverage'] = fuzz.trapmf(self.consequents[id].universe, [5, 15, 35, 45])
        self.consequents[id]['medium'] = fuzz.trapmf(self.consequents[id].universe, [35, 45, 60, 70])
        self.consequents[id]['good'] = fuzz.trapmf(self.consequents[id].universe, [60, 70, 85, 90])
        self.consequents[id]['amazing'] = fuzz.trapmf(self.consequents[id].universe, [85, 90, 100, 100])
        return self.consequents[id]

    def setConsequentsFromFile(self):
        file_path = self.get_path("consequents.txt")
        f = open(file_path)
        cons = f.read().split("%")
        for c in cons:
            self.addConsequent(c)
        f.close()

    def saveConsequentToFile(self, id):
        file_path = self.get_path("consequents.txt")
        f = open(file_path, "a")
        f.write("%" + id)
        f.close()

    # def generateRulesForConsequent(self, consequent):
    #   for a in self.ages:
    #     for l in self.lengths:
    #       self.rules.append(ctrl.Rule(self.age[a] & self.length[l], consequent[random.choice(self.rates)]))

    def addRulesForConsequents(self, inputRules, consequentId=None):
        for r in inputRules:
            if consequentId:
                rate = self.consequents[consequentId][r["rate"]]
            else:
                rate = self.consequents[r["consequentId"]][r["rate"]]
            if r["operator"] == "&":
                self.rules.append(ctrl.Rule(self.age[r["age"]] & self.length[r["length"]], rate))
            elif r["operator"] == "|":
                self.rules.append(ctrl.Rule(self.age[r["age"]] | self.length[r["length"]], rate))

    def getRulesFromFile(self):
        rules = []
        file_path = self.get_path("rules.txt")
        f = open(file_path)
        for line in f:
            splttedLine = line.split("%")
            rules.append({"consequentId": splttedLine[0], "age": splttedLine[1], "operator": splttedLine[2],
                          "length": splttedLine[3], "rate": splttedLine[4][:-1]})
        f.close()
        return rules

    def saveRulesToFile(self, consequentId, inputRules):
        file_path = self.get_path("rules.txt")
        f = open(file_path, "a")
        for r in inputRules:
            f.write(
                str(consequentId) + "%" + str(r["age"]) + "%" + str(r["operator"]) + "%" + str(r["length"]) + "%" + str(
                    r["rate"]) + "\n")
        f.close()

    def addConsequentWithRules(self, consequentId, rules):
        consequent = self.addConsequent(consequentId)
        self.saveConsequentToFile(consequentId)
        self.addRulesForConsequents(rules, consequentId)
        self.saveRulesToFile(consequentId, rules)

    def reinitRules(self):
        self.rules_ctrl = ctrl.ControlSystem(self.rules)
        self.rules_ = ctrl.ControlSystemSimulation(self.rules_ctrl)

    def initializeUserData(self, age, length):
        self.rules_.input['age'] = age
        self.rules_.input['length'] = length

    def compute(self):
        try:
            self.rules_.compute()
        except Exception as e:
            print("Rule computing error")

    def getMatchRates(self, age, length):
        results = []
        self.reinitRules()
        self.initializeUserData(int(age), int(length))
        self.compute()
        for id in self.consequents.keys():
            try:
                results.append({"id": id, "matchrate": self.rules_.output[id]})
            except Exception as e:
                print("Rules output error with", id, "anime")
                results.append({"id": id, "matchrate": 0})
        res = sorted(results, key=lambda d: d['matchrate'])
        res.reverse()
        return res

    def initializeConsequentsRules(self):
        self.setConsequentsFromFile()
        rules = self.getRulesFromFile()
        self.addRulesForConsequents(rules)


"""БД"""


class AnimeRepository():
    def __init__(self):
        self.CONNECTION_STRING = "mongodb+srv://fogdealer1:fogdealer1@cluster0.z823p.mongodb.net/myFirstDatabase?retryWrites=true&w=majority"
        self.client = MongoClient(self.CONNECTION_STRING)
        self.db = self.client['fuzzy']
        self.collection = self.db["anime"]

    def getNextId(self):
        lastAnime = self.collection.find_one(sort=[("id", -1)])
        lastNumber = int(lastAnime["id"][5:])
        nextId = "anime" + str(lastNumber + 1)
        return nextId

    def get_path(self, filename):
        file_path = os.path.abspath(__file__)
        edited_path = file_path[:-28].replace("\\", "/") + "assets/images/"
        res_path = edited_path + filename
        return res_path

    def getAll(self):
        result = []
        items = self.collection.find()
        for item in items:
            item.pop('_id')
            result.append(item)
        return result

    def getOneById(self, id):
        result = self.collection.find_one({'id': id})
        result.pop("_id")
        return result

    def add(self, anime):
        import requests
        url = anime["image"]
        r = requests.get(url, allow_redirects=True)

        filename = self.get_path(anime["title"] + ".jpg")

        open(filename, 'wb').write(r.content)

        newId = self.getNextId()
        anime.update({"id": newId})
        self.collection.insert_one(anime)
        return anime


"""ЯДРО"""


class Kernel():
    def __init__(self):
        self.fuzzyKernel = FuzzyKernel()
        self.repository = AnimeRepository()
        self.fuzzyKernel.initializeConsequentsRules()

    def recommendAnime(self, age, length):
        results = self.fuzzyKernel.getMatchRates(age, length)
        for index in range(len(results)):
            dbItem = self.repository.getOneById(results[index]["id"])
            results[index].update(dbItem)
            results[index].update({"img_src": "images/" + results[index]["title"] + ".jpg"})
            results[index]["matchrate"] = float("{:.2f}".format(results[index]["matchrate"]))
        return results

    def addAnime(self, animeData, rules):
        savedAnime = self.repository.add(animeData)
        id = savedAnime["id"]
        self.fuzzyKernel.addConsequentWithRules(id, rules)
        savedAnime.update({"rules": rules})
        return savedAnime


    def getAllRules(self):
        results = self.fuzzyKernel.getRulesFromFile()
        return results

    def getAnimeDataFromRequest(self, post):
        return {"title": post.get("title"), "year": post.get("year"), "genre": post.get("genre"), "image": post.get("image")}

    def getRulesFromRequest(self, post):
        rules = []
        rowsAmount = int(post.get("amount"))
        for i in range(rowsAmount):
            if i == 0:
                dictionary = {"age": post.get("age"), "operator": post.get("operator"),
                              "length": post.get("length"), "rate": post.get("rate")}
                rules.append(dictionary)
            else:
                dictionary = {"age": post.get("age" + str(i)), "operator": post.get("operator" + str(i)),
                              "length": post.get("length" + str(i)), "rate": post.get("rate" + str(i))}
                rules.append(dictionary)
        return rules

# data = {"title":"a", "year":"b", "genre": "c"}
# rules = [{"age":"baby", "operator": "&", "length":"medium", "rate":"anything"},
#                       {"age":"teen", "operator": "&", "length":"medium", "rate":"amazing"}]
#
# x = kernel.addAnime(data, rules)
# print(x)
